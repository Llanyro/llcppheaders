//////////////////////////////////////////////
//	NodeNext.hpp							//
//											//
//	Author: Francisco Julio Ruiz Fernandez	//
//	Author: llanyro							//
//											//
//	Version: 9.0							//
//////////////////////////////////////////////

#if defined(LLANYLIB_NODENEXT_HPP_) // Guard && version protector
	#if LLANYLIB_NODENEXT_MAYOR_ != 9 || LLANYLIB_NODENEXT_MINOR_ < 0
		#if defined(LL_REAL_CXX23)
			#warning "NodeNext.hpp version error!"
		#else
			#error "NodeNext.hpp version error!"
		#endif // LL_REAL_CXX23
	#endif // LLANYLIB_NODENEXT_MAYOR_ || LLANYLIB_NODENEXT_MINOR_

#else !defined(LLANYLIB_NODENEXT_HPP_)
#define LLANYLIB_NODENEXT_HPP_
#define LLANYLIB_NODENEXT_MAYOR_ 9
#define LLANYLIB_NODENEXT_MINOR_ 0

#include "Node.hpp"

namespace llcpp {
namespace meta {
namespace linked {

//////////////////////////////////////////////////////////////////////
// Do not change - Autogenerated with __LL_NAMED_NODE__             //
// 	macros and visual studio										//
//////////////////////////////////////////////////////////////////////
//__LL_NAMED_NODE__(Next);
template <class Node_Type_Or_Functions, ll_bool_t IS_SPECIAL = llcpp::FALSE> class NodeNext : private Node<Node_Type_Or_Functions, IS_SPECIAL> {
public: using _MyType = NodeNext; using ExtraClass = Node_Type_Or_Functions; using Node = Node<Node_Type_Or_Functions, IS_SPECIAL>; using NodeType = std::conditional_t<IS_SPECIAL, NodeNext, ExtraClass>; public: static constexpr ll_bool_t IS_SPECIAL_NODE = IS_SPECIAL; public: constexpr NodeNext() noexcept : Node(nullptr) {} constexpr NodeNext(NodeType* next) noexcept : Node(next) {} constexpr ~NodeNext() noexcept {} public: constexpr NodeNext(const NodeNext&) noexcept = delete; constexpr NodeNext& operator=(const NodeNext&) noexcept = delete; constexpr NodeNext(NodeNext&&) noexcept = delete; constexpr NodeNext& operator=(NodeNext&&) noexcept = delete; public: [[nodiscard]] constexpr operator const NodeNext* () const noexcept {
    return this;
} [[nodiscard]] constexpr operator NodeNext* () noexcept {
    return this;
} public: [[nodiscard]] constexpr const NodeType* getNext() const noexcept {
    return Node::get();
} [[nodiscard]] constexpr NodeType* getNext() noexcept {
    return Node::get();
} constexpr void setNext(NodeType* next) noexcept {
    Node::set(next);
} [[nodiscard]] constexpr NodeType* getNextNoThis() noexcept {
    return Node::getNoThis();
} [[nodiscard]] constexpr const NodeType* getNextNoThis() const noexcept {
    return Node::getNoThis();
} [[nodiscard]] constexpr NodeType* getNext(len_t moves) noexcept {
    return Node::get(moves);
} [[nodiscard]] constexpr const NodeType* getNext(len_t moves) const noexcept {
    return Node::get(moves);
}
}; template<class NodeType> using SimpleNext = NodeNext<NodeType, llcpp::FALSE>; template<class NodeFunctions> using FunctionalNext = NodeNext<NodeFunctions, llcpp::FALSE>;

} // namespace linked
} // namespace meta
} // namespace llcpp

#endif // LLANYLIB_NODENEXT_HPP_

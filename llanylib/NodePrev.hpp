//////////////////////////////////////////////
//	NodePrev.hpp							//
//											//
//	Author: Francisco Julio Ruiz Fernandez	//
//	Author: llanyro							//
//											//
//	Version: 9.0							//
//////////////////////////////////////////////

#if defined(LLANYLIB_NODEPREV_HPP_) // Guard && version protector
	#if LLANYLIB_NODEPREV_MAYOR_ != 9 || LLANYLIB_NODEPREV_MINOR_ < 0
		#if defined(LL_REAL_CXX23)
			#warning "NodePrev.hpp version error!"
		#else
			#error "NodePrev.hpp version error!"
		#endif // LL_REAL_CXX23
	#endif // LLANYLIB_NODEPREV_MAYOR_ || LLANYLIB_NODEPREV_MINOR_

#else !defined(LLANYLIB_NODEPREV_HPP_)
#define LLANYLIB_NODEPREV_HPP_
#define LLANYLIB_NODEPREV_MAYOR_ 9
#define LLANYLIB_NODEPREV_MINOR_ 0

#include "Node.hpp"

namespace llcpp {
namespace meta {
namespace linked {

//////////////////////////////////////////////////////////////////////
// Do not change - Autogenerated with __LL_NAMED_NODE__             //
// 	macros and visual studio										//
//////////////////////////////////////////////////////////////////////
//__LL_NAMED_NODE__(Prev);
template <class Node_Type_Or_Functions, ll_bool_t IS_SPECIAL = llcpp::LL_FALSE> class NodePrev : private Node<Node_Type_Or_Functions, IS_SPECIAL> {
public: using _MyType = NodePrev; using ExtraClass = Node_Type_Or_Functions; using Node = Node<Node_Type_Or_Functions, IS_SPECIAL>; using NodeType = std::conditional_t<IS_SPECIAL, NodePrev, ExtraClass>; public: static constexpr ll_bool_t IS_SPECIAL_NODE = IS_SPECIAL; public: constexpr NodePrev() noexcept : Node(nullptr) {} constexpr NodePrev(NodeType* next) noexcept : Node(next) {} constexpr ~NodePrev() noexcept {} public: constexpr NodePrev(const NodePrev&) noexcept = delete; constexpr NodePrev& operator=(const NodePrev&) noexcept = delete; constexpr NodePrev(NodePrev&&) noexcept = delete; constexpr NodePrev& operator=(NodePrev&&) noexcept = delete; public: [[nodiscard]] constexpr operator const NodePrev* () const noexcept {
    return this;
} [[nodiscard]] constexpr operator NodePrev* () noexcept {
    return this;
} public: [[nodiscard]] constexpr const NodeType* getPrev() const noexcept {
    return Node::get();
} [[nodiscard]] constexpr NodeType* getPrev() noexcept {
    return Node::get();
} constexpr void setPrev(NodeType* next) noexcept {
    Node::set(next);
} [[nodiscard]] constexpr NodeType* getPrevNoThis() noexcept {
    return Node::getNoThis();
} [[nodiscard]] constexpr const NodeType* getPrevNoThis() const noexcept {
    return Node::getNoThis();
} [[nodiscard]] constexpr NodeType* getPrev(len_t moves) noexcept {
    return Node::get(moves);
} [[nodiscard]] constexpr const NodeType* getPrev(len_t moves) const noexcept {
    return Node::get(moves);
}
}; template<class NodeType> using SimplePrev = NodePrev<NodeType, llcpp::LL_FALSE>; template<class NodeFunctions> using FunctionalPrev = NodePrev<NodeFunctions, llcpp::LL_FALSE>;

} // namespace linked
} // namespace meta
} // namespace llcpp

#endif // LLANYLIB_NODEPREV_HPP_

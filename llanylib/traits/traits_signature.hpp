//////////////////////////////////////////////
//	traits_signature.hpp					//
//											//
//	Author: Francisco Julio Ruiz Fernandez	//
//	Author: llanyro							//
//											//
//	Version: 10.0							//
//////////////////////////////////////////////

#if defined(LLANYLIB_TRAITSSIGNATURE_HPP_) // Guard && version protector
	#if LLANYLIB_TRAITSSIGNATURE_MAYOR_ != 10 || LLANYLIB_TRAITSSIGNATURE_MINOR_ < 0
		#if defined(__LL_REAL_CXX23)
			#warning "traits_signature.hpp version error!"
		#else
			#error "traits_signature.hpp version error!"
		#endif // __LL_REAL_CXX23
	#endif // LLANYLIB_TRAITSSIGNATURE_MAYOR_ || LLANYLIB_TRAITSSIGNATURE_MINOR_

#else !defined(LLANYLIB_TRAITSSIGNATURE_HPP_)
#define LLANYLIB_TRAITSSIGNATURE_HPP_
#define LLANYLIB_TRAITSSIGNATURE_MAYOR_ 10
#define LLANYLIB_TRAITSSIGNATURE_MINOR_ 0

#include "traits_checker.hpp"

namespace llcpp {
namespace meta {
namespace traits {

// SFINAE to check if object has a function
// Follow any class that this inherites to check how to do a new checker 
template<class _Base>
struct _has_common : public _Base {
	// Class related
	using _MyType		= _has_common;
	using Base			= _Base;
	using ClassToCheck	= typename Base::ClassToCheck;

	// Types and enums
	using type			= decltype(Base::template test<ClassToCheck>(LL_NULLPTR));

	// Asserts
	static_assert(traits::is_valid_type_checker_v<ClassToCheck>,
		"type_checker<ClassToCheck> detected an invalid type!");
	static_assert(traits::is_valid_constructor_checker_v<ClassToCheck>,
		"constructor_checker<ClassToCheck> detected an invalid class type!");
	static_assert(std::is_class_v<ClassToCheck>,
		"ClassToCheck is not a class!");
};

template<class _ClassToCheck, class _OperatorType, class _Signature>
struct has_type_operator {
	// Class related
	using _MyType		= has_type_operator;

	// Types and enums
	using ClassToCheck	= _ClassToCheck;
	using OperatorType	= _OperatorType;
	using Signature		= _Signature;
	template<ll_bool_t, ll_bool_t> struct SFINAE { using type = std::false_type; };
	template<> struct SFINAE<llcpp::TRUE, llcpp::TRUE> { using type = std::true_type; };
	using type_default_result =
		typename SFINAE<traits::is_basic_type_v<ClassToCheck>, std::is_same_v<ClassToCheck, OperatorType>>::type;

	// Functions
	template<class U>
	static constexpr auto test(Signature) noexcept -> std::true_type;
	template<class U>
	static constexpr auto test(...) noexcept -> type_default_result;
	using type = decltype(has_type_operator::test<ClassToCheck>(&ClassToCheck::operator OperatorType));
};

template<class ClassToCheck, class OperatorType, class Signature>
__LL_VAR_INLINE__ constexpr ll_bool_t has_type_operator_v = traits::has_type_operator<ClassToCheck, OperatorType, Signature>::type::value;
template<class ClassToCheck, class OperatorType>
__LL_VAR_INLINE__ constexpr ll_bool_t has_simple_type_operator_v =
	traits::has_type_operator<ClassToCheck, OperatorType, OperatorType(T_Class<ClassToCheck>::*)() noexcept>::type::value;
template<class ClassToCheck, class OperatorType>
__LL_VAR_INLINE__ constexpr ll_bool_t has_simple_type_const_operator_v =
	traits::has_type_operator<ClassToCheck, OperatorType, OperatorType(T_Class<ClassToCheck>::*)() const noexcept>::type::value;

namespace common {

#define __LL_HAS_CUSTOM_FUNCTION_NAMED__(name, functionname) \
	template<class _ClassToCheck, class _Signature> \
	struct has_##name##_function { \
		using _MyType		= has_##name##_function; \
		using ClassToCheck	= _ClassToCheck; \
		using Signature		= _Signature; \
		template<_Signature SIG> \
		using checker		= traits::SignatureChecker<_ClassToCheck, _Signature, SIG>; \
		template<class _U> \
		static constexpr auto test(checker<&_U::##functionname##>*) noexcept	-> std::true_type; \
		template<class _U> static constexpr auto test(...) noexcept				-> std::false_type; \
	}; \
	template<class ClassToCheck, class Signature> \
	using has_##name##_function_t = \
		traits::_has_common<traits::common::has_##name##_function<ClassToCheck, Signature>>; \
	template<class ClassToCheck, class Signature> \
	__LL_VAR_INLINE__ constexpr ll_bool_t has_##name##_function_v = \
		traits::common::has_##name##_function_t<ClassToCheck, Signature>::type::value;

#define __LL_HAS_CUSTOM_FUNCTION__(name) __LL_HAS_CUSTOM_FUNCTION_NAMED__(name, name)

//////////////////////////////////////////////////////////////////////
// Do not change - Autogenerated with __LL_HAS_CUSTOM_FUNCTION__	//
// 	macros and visual studio										//
//////////////////////////////////////////////////////////////////////
//__LL_HAS_CUSTOM_FUNCTION__(hash);
//__LL_HAS_CUSTOM_FUNCTION__(clear);
//__LL_HAS_CUSTOM_FUNCTION__(swap);
//__LL_HAS_CUSTOM_FUNCTION__(copy);
//__LL_HAS_CUSTOM_FUNCTION__(move);
//__LL_HAS_CUSTOM_FUNCTION__(compare);
//__LL_HAS_CUSTOM_FUNCTION__(compareBool);
//__LL_HAS_CUSTOM_FUNCTION__(predestruction);
//__LL_HAS_CUSTOM_FUNCTION__(nodeChecker);
//__LL_HAS_CUSTOM_FUNCTION__(compareNode);
//__LL_HAS_CUSTOM_FUNCTION__(compare_eq);
//__LL_HAS_CUSTOM_FUNCTION__(compare_no_eq);
//__LL_HAS_CUSTOM_FUNCTION__(die);
//__LL_HAS_CUSTOM_FUNCTION__(combine);
//__LL_HAS_CUSTOM_FUNCTION__(compare_strong);
//__LL_HAS_CUSTOM_FUNCTION_NAMED__(operator_eq, operator==);
//__LL_HAS_CUSTOM_FUNCTION_NAMED__(operator_no_eq, operator!=);
//__LL_HAS_CUSTOM_FUNCTION_NAMED__(operator_greater, operator>);
//__LL_HAS_CUSTOM_FUNCTION_NAMED__(operator_lower, operator<);
//__LL_HAS_CUSTOM_FUNCTION_NAMED__(operator_eq_greater, operator>=);
//__LL_HAS_CUSTOM_FUNCTION_NAMED__(operator_eq_lower, operator<=);
//__LL_HAS_CUSTOM_FUNCTION_NAMED__(sgtrong_ordening, operator<=>);

template<class _ClassToCheck, class _Signature> struct has_hash_function {
	using _MyType = has_hash_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::hash>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_hash_function_t = traits::_has_common<traits::common::has_hash_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_hash_function_v = traits::common::has_hash_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_clear_function {
	using _MyType = has_clear_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::clear>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_clear_function_t = traits::_has_common<traits::common::has_clear_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_clear_function_v = traits::common::has_clear_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_swap_function {
	using _MyType = has_swap_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::swap>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_swap_function_t = traits::_has_common<traits::common::has_swap_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_swap_function_v = traits::common::has_swap_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_copy_function {
	using _MyType = has_copy_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::copy>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_copy_function_t = traits::_has_common<traits::common::has_copy_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_copy_function_v = traits::common::has_copy_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_move_function {
	using _MyType = has_move_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::move>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_move_function_t = traits::_has_common<traits::common::has_move_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_move_function_v = traits::common::has_move_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_compare_function {
	using _MyType = has_compare_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::compare>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_compare_function_t = traits::_has_common<traits::common::has_compare_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_compare_function_v = traits::common::has_compare_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_compareBool_function {
	using _MyType = has_compareBool_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::compareBool>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_compareBool_function_t = traits::_has_common<traits::common::has_compareBool_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_compareBool_function_v = traits::common::has_compareBool_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_predestruction_function {
	using _MyType = has_predestruction_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::predestruction>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_predestruction_function_t = traits::_has_common<traits::common::has_predestruction_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_predestruction_function_v = traits::common::has_predestruction_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_nodeChecker_function {
	using _MyType = has_nodeChecker_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::nodeChecker>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_nodeChecker_function_t = traits::_has_common<traits::common::has_nodeChecker_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_nodeChecker_function_v = traits::common::has_nodeChecker_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_compareNode_function {
	using _MyType = has_compareNode_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::compareNode>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_compareNode_function_t = traits::_has_common<traits::common::has_compareNode_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_compareNode_function_v = traits::common::has_compareNode_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_compare_eq_function {
	using _MyType = has_compare_eq_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::compare_eq>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_compare_eq_function_t = traits::_has_common<traits::common::has_compare_eq_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_compare_eq_function_v = traits::common::has_compare_eq_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_compare_no_eq_function {
	using _MyType = has_compare_no_eq_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::compare_no_eq>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_compare_no_eq_function_t = traits::_has_common<traits::common::has_compare_no_eq_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_compare_no_eq_function_v = traits::common::has_compare_no_eq_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_die_function {
	using _MyType = has_die_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::die>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_die_function_t = traits::_has_common<traits::common::has_die_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_die_function_v = traits::common::has_die_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_combine_function {
	using _MyType = has_combine_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<_Signature SIG> using checker = traits::SignatureChecker<_ClassToCheck, _Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::combine>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_combine_function_t = traits::_has_common<traits::common::has_combine_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_combine_function_v = traits::common::has_combine_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_compare_strong_function {
	using _MyType = has_compare_strong_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<_Signature SIG> using checker = traits::SignatureChecker<_ClassToCheck, _Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::compare_strong>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_compare_strong_function_t = traits::_has_common<traits::common::has_compare_strong_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_compare_strong_function_v = traits::common::has_compare_strong_function_t<ClassToCheck, Signature>::type::value;;

template<class ClassToCheck>
__LL_VAR_INLINE__ constexpr ll_bool_t has_simple_clear_function_v =
	traits::common::has_clear_function_v<ClassToCheck, void(ClassToCheck::*)() noexcept>;

template<class _ClassToCheck, class _Signature> struct has_operator_eq_function {
	using _MyType = has_operator_eq_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker <&_U::operator==>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_operator_eq_function_t = traits::_has_common<traits::common::has_operator_eq_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_operator_eq_function_v = traits::common::has_operator_eq_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_operator_greater_function {
	using _MyType = has_operator_greater_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<_Signature SIG> using checker = traits::SignatureChecker<_ClassToCheck, _Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::operator>>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_operator_greater_function_t = traits::_has_common<traits::common::has_operator_greater_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_operator_greater_function_v = traits::common::has_operator_greater_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_operator_lower_function {
	using _MyType = has_operator_lower_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<_Signature SIG> using checker = traits::SignatureChecker<_ClassToCheck, _Signature, SIG>; template<class _U> static constexpr auto test(checker < &_U::operator<>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_operator_lower_function_t = traits::_has_common<traits::common::has_operator_lower_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_operator_lower_function_v = traits::common::has_operator_lower_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_operator_eq_greater_function {
	using _MyType = has_operator_eq_greater_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<_Signature SIG> using checker = traits::SignatureChecker<_ClassToCheck, _Signature, SIG>; template<class _U> static constexpr auto test(checker < &_U::operator>=>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_operator_eq_greater_function_t = traits::_has_common<traits::common::has_operator_eq_greater_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_operator_eq_greater_function_v = traits::common::has_operator_eq_greater_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_operator_eq_lower_function {
	using _MyType = has_operator_eq_lower_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<_Signature SIG> using checker = traits::SignatureChecker<_ClassToCheck, _Signature, SIG>; template<class _U> static constexpr auto test(checker < &_U::operator<=>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_operator_eq_lower_function_t = traits::_has_common<traits::common::has_operator_eq_lower_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_operator_eq_lower_function_v = traits::common::has_operator_eq_lower_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_operator_no_eq_function {
	using _MyType = has_operator_no_eq_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker < &_U::operator!=>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_operator_no_eq_function_t = traits::_has_common<traits::common::has_operator_no_eq_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_operator_no_eq_function_v = traits::common::has_operator_no_eq_function_t<ClassToCheck, Signature>::type::value;
template<class _ClassToCheck, class _Signature> struct has_sgtrong_ordening_function {
	using _MyType = has_sgtrong_ordening_function; using ClassToCheck = _ClassToCheck; using Signature = _Signature; template<Signature SIG> using checker = traits::SignatureChecker<ClassToCheck, Signature, SIG>; template<class _U> static constexpr auto test(checker<&_U::operator<=>>*) noexcept -> std::true_type; template<class _U> static constexpr auto test(...) noexcept -> std::false_type;
}; template<class ClassToCheck, class Signature> using has_sgtrong_ordening_function_t = traits::_has_common<traits::common::has_sgtrong_ordening_function<ClassToCheck, Signature>>; template<class ClassToCheck, class Signature> inline constexpr ll_bool_t has_sgtrong_ordening_function_v = traits::common::has_sgtrong_ordening_function_t<ClassToCheck, Signature>::type::value;

} // namespace common

} // namespace traits
} // namespace meta
} // namespace llcpp

#endif // LLANYLIB_TRAITSSIGNATURE_HPP_
